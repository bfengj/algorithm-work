# 自行实现算法-BFPTR算法

## 算法原理
BFPTR算法是解决TOP-K问题的一个很好的算法，它可以看成是快排的改进，主要在于修改了主元的选取。
在BFPTR算法中用到了插入排序，基本思路就是从头到尾的遍历序列，如果当前元素比前面已经排好的序列中的后部分元素大（从大到小排序），就不断地往左移动，直到移动到左边地元素比它大，右边地元素比它小地位置，这一步骤看作是”插入”，这样遍历下来就实现了排序。
首先将序列的元素划分为x组，每组5个元素（除了最后一组），然后依次对每个组利用插入排序求中位数，将得到的所有中位数再次当成一个序列，对这个序列再次应用上述操作，直到得到的中位数只有一个.
这时候就把这个中位数当成主元，对原来的序列进行一次快排。排序之后看当前这个主元的索引和K的关系，如果等于K-1（因为索引从0开始）就将这个数返回，如果小于K-1就对右边的序列递归进行上述操作，如果大于K-1就对左边的序列递归进行上述操作。
在寻找中位数的步骤上，我为了减少空间的利用，将每组的中位数都放到整个序列的首部，然后再递归操作前面这部分，不再使用额外的空间（这个函数对vector没有&操作，所以不影响原本的序列），直到最前面放入的中位数数量为1的时候便认为找到了中位数。
这个算法我认为好就好在，不需要对整个序列进行排序。

# 输出序列的各百分位数对应的关键字值
将其看作是TOP-K来解决，输入一个百分位数，将其转化为K之后，利用BFPTR算法求得TOP-K即可得到了关键字。
# 统计任意给定的两个关键字区段间数据所占的比例
先利用快速排序将整个序列从大到小排序，然后使用二分查找，对于大的那个关键字，找小于等于它的第一个索引；对于小的那个关键字，找大于等于它的最后一个元素的索引即可，因此这二者的二分查找细节上需要有一些调整，前者的mid的选取需要靠近左边界（int mid = start + (end-start)/2;），然后由左边界不断的逼近；后者的mid的选取要靠近右边界（int mid = end - (end-start)/2;），然后由右边界不断的逼近。
# 剔除前后m%的异常数据
也是看作TOP-K问题，使用BFPTR算法求得TOP-K和TOP-n-K，这时候就不再需要使用快排排序了，直接将序列的k到n-k这部分返回即可。